"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zen2han = exports.n2kan = exports.kan2n = exports.splitLargeNumber = exports.normalize = exports.smallNumbers = exports.largeNumbers = void 0;
const oldJapaneseNumerics_1 = require("./oldJapaneseNumerics");
const japaneseNumerics_1 = require("./japaneseNumerics");
exports.largeNumbers = { '兆': 1000000000000, '億': 100000000, '万': 10000 };
exports.smallNumbers = { '千': 1000, '百': 100, '十': 10 };
function normalize(japanese) {
    for (const key in oldJapaneseNumerics_1.default) {
        const reg = new RegExp(key, 'g');
        japanese = japanese.replace(reg, oldJapaneseNumerics_1.default[key]);
    }
    return japanese;
}
exports.normalize = normalize;
/**
 * 漢数字を兆、億、万単位に分割する
 */
function splitLargeNumber(japanese) {
    let kanji = japanese;
    const numbers = {};
    for (const key in exports.largeNumbers) {
        const reg = new RegExp(`(.+)${key}`);
        const match = kanji.match(reg);
        if (match) {
            numbers[key] = kan2n(match[1]);
            kanji = kanji.replace(match[0], '');
        }
        else {
            numbers[key] = 0;
        }
    }
    if (kanji) {
        numbers['千'] = kan2n(kanji);
    }
    else {
        numbers['千'] = 0;
    }
    return numbers;
}
exports.splitLargeNumber = splitLargeNumber;
/**
 * 千単位以下の漢数字を数字に変換する（例: 三千 => 3000）
 *
 * @param japanese
 */
function kan2n(japanese) {
    if (japanese.match(/^[0-9]+$/)) {
        return Number(japanese);
    }
    let kanji = zen2han(japanese);
    let number = 0;
    for (const key in exports.smallNumbers) {
        const reg = new RegExp(`(.*)${key}`);
        const match = kanji.match(reg);
        if (match) {
            let n = 1;
            if (match[1]) {
                if (match[1].match(/^[0-9]+$/)) {
                    n = Number(match[1]);
                }
                else {
                    n = japaneseNumerics_1.default[match[1]];
                }
            }
            number = number + (n * exports.smallNumbers[key]);
            kanji = kanji.replace(match[0], '');
        }
    }
    if (kanji) {
        if (kanji.match(/^[0-9]+$/)) {
            number = number + Number(kanji);
        }
        else {
            for (let index = 0; index < kanji.length; index++) {
                const char = kanji[index];
                const digit = kanji.length - index - 1;
                number = number + japaneseNumerics_1.default[char] * (10 ** digit);
            }
        }
    }
    return number;
}
exports.kan2n = kan2n;
/**
 * Converts number less than 10000 to kanji.
 *
 * @param num
 */
function n2kan(num) {
    const kanjiNumbers = Object.keys(japaneseNumerics_1.default);
    let number = num;
    let kanji = '';
    for (const key in exports.smallNumbers) {
        const n = Math.floor(number / exports.smallNumbers[key]);
        if (n) {
            number = number - (n * exports.smallNumbers[key]);
            if (1 === n) {
                kanji = `${kanji}${key}`;
            }
            else {
                kanji = `${kanji}${kanjiNumbers[n]}${key}`;
            }
        }
    }
    if (number) {
        kanji = `${kanji}${kanjiNumbers[number]}`;
    }
    return kanji;
}
exports.n2kan = n2kan;
/**
 * Converts double-width number to number as string.
 *
 * @param num
 */
function zen2han(str) {
    return str.replace(/[０-９]/g, (s) => {
        return String.fromCharCode(s.charCodeAt(0) - 0xFEE0);
    });
}
exports.zen2han = zen2han;
